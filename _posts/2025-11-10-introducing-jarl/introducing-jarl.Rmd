---
title: "Jarl: just another R linter"
description: |
  Remove bad patterns in your R code in the blink of an eye.
author:
  - name: Etienne Bacher
    url: {}
date: 2025-11-10
output:
  distill::distill_article:
    toc: true
---

<!-- DON'T FORGET ALT TEXT FOR GIFS -->

I'm very excited to introduce Jarl^[Jarl stands for "Just Another R Linter".], a new R linter.
A linter is a tool that statically parses code (meaning that it doesn't run the code in question) and searches for patterns that are inefficient, hard to read, or likely bugs.

Jarl can parse dozens of files and thousands of lines of code in milliseconds.
Here is an example of Jarl running on [r-source](https://github.com/wch/r-source/) (approximately 1000 files and 200k lines of R code) in about 700 milliseconds:

<video width="100%" height="100%" alt="Running `jarl check . --with-timing` on the 'r-source' repository. This runs in about 700ms and returns hundreds of rule violations detailing the diagnostic and how to fix it." controls>
  <source src="demos/lint-r-source.webm" type="video/mp4">
</video>

<br>

On top of that, Jarl can apply automatic fixes^[This is not always possible, it depends on the rule.].
Suppose that we have the following file `foo.R`:

```r
x <- any(is.na(mtcars))

f <- function(x) {
  apply(x, 1, mean)
}
```

There are two rule violations in this file:

1. `any(is.na(mtcars))` should be replaced by `anyNA(mtcars)`^[`anyNA(x)` is more efficient than `any(is.na(x))`.];
1. `apply(x, 1, mean)` should be replaced by `rowMeans(x)`^[`rowMeans(x)` is more efficient than `apply(x, 1, mean)`.].

Instead of fixing those cases by hand, we can run the following command in the terminal (not in the R console):

```sh
jarl check foo.R --fix
```

After running this, `foo.R` now contains the following code:

```r
x <- anyNA(mtcars)

f <- function(x) {
  rowMeans(x)
}
```

(Note that `f` is now useless since it is equivalent to `rowMeans()`.)

Jarl stands on the shoulders of giants, in particular:

* [lintr](https://lintr.r-lib.org/): this R package provides dozens of rules from various sources to lint R code, and Jarl wouldn't exist without this package. Jarl currently supports 25 `lintr` rules.
* [Air](https://posit-dev.github.io/air/): this is a fast R formatter written in Rust, developed by Lionel Henry and Davis Vaughan, and released earlier this year. It is also a command-line tool that runs in the terminal. It is the technical foundation on which Jarl is built since Air provides the infrastructure to parse and manipulate R code.

Jarl is a single binary, meaning that it doesn't need an R installation to work.
This makes it a very attractive option for continuous integration for instance, since it takes less than 10 seconds to download the binary and run it on the repository.

## Using Jarl

There are two ways to use Jarl:

1. via the terminal, using `jarl check [OPTIONS]`;
2. using the integration in your coding editor (at the time of writing, only VS Code and Positron have a Jarl extension, but support for Zed is coming soon<sup>TM</sup>).

The Jarl extension enables code highlighting and quick fixes.
The former means that code that violates any of the rules in your setup (more on this below) will be underlined and will show the exact violation when hovered.

<video width="100%" height="100%" alt="This shows the same file 'foo.R', but this time the two pieces of code that violate the rules are underlined in yellow. Hovering these two pieces of code show a popup detailing the diagnostic." controls>
  <source src="demos/hover.webm" type="video/mp4">
</video>

<br>

The latter adds a lightbulb button next to rule violations, allowing you to selectively apply fixes.

<video width="100%" height="100%" alt="This shows the same file 'foo.R'. This time, clicking on the code that violate the rules displays a small lightbulb icon that applies the automatic fix when clicked." controls>
  <source src="demos/quick-fixes.webm" type="video/mp4">
</video>

<br>

In the future, those extensions could have a "Fix on save" feature similar to the "Format on save" functionality provided by Air.


## Configuring Jarl

By default, Jarl will report violations for almost of its rules.
It is possible to configure its behavior using a configuration file named `jarl.toml`.
In particular, in this file, you can specify:

* the rules you want to apply,
* the files to include or exclude,
* the rules for which you want to apply automatic fixes,

and more.

## Conclusion

Jarl is in its early days, there are more rules and options to add.
Still, it can already be used in interactive use or in continuous integration (check out the [`setup-jarl` workflow](https://github.com/etiennebacher/setup-jarl)!).
Eventually, many `lintr` rules should be supported in Jarl, but the end goal is not to have perfect compatibility.
`lintr` provides many rules related to code formatting (e.g. [spaces_inside_linter](https://lintr.r-lib.org/dev/reference/spaces_inside_linter.html)).
Those will not be integrated in Jarl since they are already covered by Air.
Additionally (for now), Jarl cannot perform semantic analysis^[Semantic analysis refers to using the context surrounding an expression to explore rule violations.], meaning that some `lintr` rules are out of scope (e.g. [unreachable_code_linter](https://lintr.r-lib.org/dev/reference/unreachable_code_linter.html)).

This was a very light introduction, go to the [Jarl website](https://jarl.etiennebacher.com/) for more information.

If you want to help developing Jarl, check out the ["Contributing" page](https://jarl.etiennebacher.com/contributing).
Jarl is written in Rust, which may be a barrier to contributing but is also a very powerful language which is a real pleasure to use.
I will add a more detailed tutorial soon so that this can also be a nice introduction to this language.
You can also contribute to the documentation!

# Acknowledgements

As I said above, Jarl depends enormously on the work of [`lintr`](https://lintr.r-lib.org/authors.html) and Air developers, so thank you!

Jarl is also very inspired by similar tools in other languages, in particular [Ruff](https://docs.astral.sh/ruff/) in Python and [Cargo clippy](https://github.com/rust-lang/rust-clippy) in Rust.

Finally, thanks to the [R Consortium](https://r-consortium.org/) for funding part of the development of Jarl via the ISC Grant Program.

And thank you, MaÃ«lle, for improving the draft!
